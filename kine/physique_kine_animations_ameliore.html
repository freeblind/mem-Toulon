<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animations Physique Ultra-D√©taill√©es - Kin√©sith√©rapie</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 60px 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.9), rgba(118, 75, 162, 0.9));
            border-radius: 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        header::before {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
            top: -50%;
            left: -50%;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
        }

        h1 {
            font-size: 3.5em;
            margin-bottom: 15px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            position: relative;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.4em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }

        .nav-tabs {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 40px;
        }

        .tab {
            padding: 15px 30px;
            background: rgba(102, 126, 234, 0.2);
            border: 2px solid rgba(102, 126, 234, 0.4);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.1em;
            font-weight: 600;
        }

        .tab:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .tab.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-color: #667eea;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
            animation: fadeInUp 0.6s ease;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .animation-block {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            backdrop-filter: blur(10px);
        }

        .block-title {
            font-size: 2.2em;
            margin-bottom: 30px;
            text-align: center;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            margin: 0 auto 30px;
            border-radius: 15px;
            background: rgba(0,0,0,0.7);
            box-shadow: 
                0 15px 35px rgba(0,0,0,0.5),
                inset 0 0 50px rgba(102, 126, 234, 0.1);
            border: 3px solid rgba(102, 126, 234, 0.3);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.25);
        }

        .control-label {
            display: block;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 12px;
            font-size: 1em;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .control-value {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 6px 18px;
            border-radius: 20px;
            margin-left: 12px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.3));
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.8);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 30px 0;
        }

        .btn {
            padding: 15px 35px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 50px;
            color: white;
            font-weight: 700;
            font-size: 1.05em;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .data-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .data-card {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid rgba(102, 126, 234, 0.3);
        }

        .data-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .data-value {
            font-size: 1.8em;
            font-weight: 900;
            color: #667eea;
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }

        .info-panel {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border-left: 5px solid #667eea;
            padding: 30px;
            border-radius: 12px;
            margin-top: 30px;
        }

        .info-panel h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.6em;
        }

        .equation {
            background: rgba(0, 0, 0, 0.5);
            padding: 18px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.3em;
            text-align: center;
            margin: 18px 0;
            border: 2px solid rgba(102, 126, 234, 0.4);
            color: #4facfe;
            font-weight: 600;
        }

        .info-panel ul {
            list-style: none;
            line-height: 2;
        }

        .info-panel li::before {
            content: "‚ñ∏ ";
            color: #667eea;
            font-weight: bold;
            margin-right: 10px;
            font-size: 1.2em;
        }

        .legend {
            display: flex;
            gap: 25px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 25px 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.08);
            padding: 12px 24px;
            border-radius: 25px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            box-shadow: 0 0 15px currentColor;
        }

        @media (max-width: 768px) {
            h1 { font-size: 2.2em; }
            .controls { grid-template-columns: 1fr; }
            canvas { max-width: 100%; height: auto !important; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚öõÔ∏è PHYSIQUE INTERACTIVE</h1>
            <p class="subtitle">Animations Ultra-D√©taill√©es | Kin√©sith√©rapie Bloc 1</p>
        </header>

        <div class="nav-tabs">
            <button class="tab active" data-section="cinematique">üìê Cin√©matique</button>
            <button class="tab" data-section="forces">‚ö° Forces</button>
            <button class="tab" data-section="energie">üîã √ânergie</button>
            <button class="tab" data-section="fluides">üíß Fluides</button>
        </div>

        <!-- CIN√âMATIQUE -->
        <div id="cinematique" class="section active">
            <div class="animation-block">
                <h2 class="block-title">üéØ Mouvement Parabolique (MRUA)</h2>
                <canvas id="mruaCanvas" width="1400" height="700"></canvas>
                
                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">
                            Vitesse initiale (v‚ÇÄ)
                            <span class="control-value" id="v0Val">20.0</span> m/s
                        </label>
                        <input type="range" id="v0Slider" min="5" max="50" step="1" value="20">
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">
                            Angle (Œ∏)
                            <span class="control-value" id="angleVal">45</span>¬∞
                        </label>
                        <input type="range" id="angleSlider" min="15" max="75" step="5" value="45">
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">
                            Gravit√© (g)
                            <span class="control-value" id="gVal">9.81</span> m/s¬≤
                        </label>
                        <input type="range" id="gSlider" min="1" max="20" step="0.5" value="9.81">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn" id="btnLaunchMRUA">üöÄ LANCER</button>
                    <button class="btn btn-secondary" id="btnResetMRUA">üîÑ RESET</button>
                    <button class="btn btn-success" id="btnToggleVectors">üìä Vecteurs</button>
                </div>

                <div class="data-grid">
                    <div class="data-card"><div class="data-label">Temps vol</div><div class="data-value" id="timeVal">0.00 s</div></div>
                    <div class="data-card"><div class="data-label">Hauteur max</div><div class="data-value" id="maxHeightVal">0.0 m</div></div>
                    <div class="data-card"><div class="data-label">Port√©e</div><div class="data-value" id="rangeVal">0.0 m</div></div>
                    <div class="data-card"><div class="data-label">Vitesse</div><div class="data-value" id="velVal">0.0 m/s</div></div>
                </div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background: #ff6b6b;"></div><span>Vecteur vitesse</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #4ecdc4;"></div><span>Vecteur acc√©l√©ration</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #ffe66d;"></div><span>Trajectoire</span></div>
                </div>

                <div class="info-panel">
                    <h3>üìö √âquations du mouvement parabolique</h3>
                    <div class="equation">x(t) = v‚ÇÄ cos(Œ∏) ¬∑ t</div>
                    <div class="equation">y(t) = v‚ÇÄ sin(Œ∏) ¬∑ t - ¬Ωgt¬≤</div>
                    <div class="equation">Port√©e = (v‚ÇÄ¬≤ sin(2Œ∏)) / g</div>
                    <div class="equation">Hauteur max = (v‚ÇÄ¬≤ sin¬≤(Œ∏)) / (2g)</div>
                    <ul>
                        <li><strong>Angle optimal</strong> : 45¬∞ pour port√©e maximale (sans r√©sistance air)</li>
                        <li><strong>Application kin√©</strong> : analyse du saut, lancer de balle, biom√©canique sportive</li>
                        <li><strong>Composantes</strong> : mouvement horizontal uniforme + mouvement vertical acc√©l√©r√©</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- FORCES -->
        <div id="forces" class="section">
            <div class="animation-block">
                <h2 class="block-title">‚ö° Plan Inclin√© & D√©composition Forces</h2>
                <canvas id="forcesCanvas" width="1400" height="700"></canvas>
                
                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">
                            Angle plan (Œ∏)
                            <span class="control-value" id="planeAngleVal">30</span>¬∞
                        </label>
                        <input type="range" id="planeAngleSlider" min="10" max="60" step="5" value="30">
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">
                            Masse (m)
                            <span class="control-value" id="massVal">10.0</span> kg
                        </label>
                        <input type="range" id="massSlider" min="1" max="30" step="1" value="10">
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">
                            Friction (Œº)
                            <span class="control-value" id="muVal">0.3</span>
                        </label>
                        <input type="range" id="muSlider" min="0" max="1" step="0.05" value="0.3">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn" id="btnSimulatePlane">‚ñ∂Ô∏è SIMULER</button>
                    <button class="btn btn-secondary" id="btnResetPlane">üîÑ RESET</button>
                </div>

                <div class="data-grid">
                    <div class="data-card"><div class="data-label">Poids (W)</div><div class="data-value" id="weightVal">0.0 N</div></div>
                    <div class="data-card"><div class="data-label">Normale (N)</div><div class="data-value" id="normalVal">0.0 N</div></div>
                    <div class="data-card"><div class="data-label">W sin Œ∏</div><div class="data-value" id="parVal">0.0 N</div></div>
                    <div class="data-card"><div class="data-label">Friction (f)</div><div class="data-value" id="fricVal">0.0 N</div></div>
                    <div class="data-card"><div class="data-label">F r√©sultante</div><div class="data-value" id="netVal">0.0 N</div></div>
                    <div class="data-card"><div class="data-label">Acc√©l√©ration</div><div class="data-value" id="accelVal">0.0 m/s¬≤</div></div>
                </div>

                <div class="info-panel">
                    <h3>üìö D√©composition des forces</h3>
                    <div class="equation">W = mg (Poids)</div>
                    <div class="equation">W_‚à• = mg sin Œ∏ (Composante parall√®le)</div>
                    <div class="equation">N = mg cos Œ∏ (Force normale)</div>
                    <div class="equation">f = ŒºN (Force de friction)</div>
                    <div class="equation">F_net = W_‚à• - f ‚Üí a = F_net/m</div>
                    <ul>
                        <li><strong>√âquilibre</strong> : F_net = 0 (objet immobile ou vitesse constante)</li>
                        <li><strong>Application kin√©</strong> : r√©√©ducation sur plan inclin√©, exercices en pente</li>
                        <li><strong>Friction</strong> : r√©sistance au glissement, d√©pend de Œº (nature des surfaces)</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- √âNERGIE -->
        <div id="energie" class="section">
            <div class="animation-block">
                <h2 class="block-title">üîã Pendule & Conservation √ânergie</h2>
                <canvas id="energieCanvas" width="1400" height="700"></canvas>
                
                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">
                            Longueur (L)
                            <span class="control-value" id="lengthVal">3.0</span> m
                        </label>
                        <input type="range" id="lengthSlider" min="1" max="5" step="0.5" value="3">
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">
                            Angle initial (Œ∏‚ÇÄ)
                            <span class="control-value" id="theta0Val">60</span>¬∞
                        </label>
                        <input type="range" id="theta0Slider" min="15" max="85" step="5" value="60">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn" id="btnLaunchPendulum">‚ñ∂Ô∏è LANCER</button>
                    <button class="btn btn-secondary" id="btnResetPendulum">üîÑ RESET</button>
                </div>

                <div class="data-grid">
                    <div class="data-card"><div class="data-label">Angle Œ∏</div><div class="data-value" id="thetaPVal">0¬∞</div></div>
                    <div class="data-card"><div class="data-label">Vitesse</div><div class="data-value" id="velPVal">0.0 m/s</div></div>
                    <div class="data-card"><div class="data-label">E_cin√©tique</div><div class="data-value" id="kePVal">0.0 J</div></div>
                    <div class="data-card"><div class="data-label">E_potentielle</div><div class="data-value" id="pePVal">0.0 J</div></div>
                    <div class="data-card"><div class="data-label">E_totale</div><div class="data-value" id="tePVal">0.0 J</div></div>
                </div>

                <div class="info-panel">
                    <h3>üìö Conservation de l'√©nergie m√©canique</h3>
                    <div class="equation">E_m√©canique = E_cin + E_pot = constante</div>
                    <div class="equation">E_cin = ¬Ωmv¬≤ | E_pot = mgh</div>
                    <div class="equation">Au point haut : E_pot max, E_cin = 0</div>
                    <div class="equation">Au point bas : E_cin max, E_pot = 0</div>
                    <ul>
                        <li><strong>Transformation</strong> : √©change continu √©nergie potentielle ‚Üî cin√©tique</li>
                        <li><strong>Application kin√©</strong> : analyse de la marche (centre de masse oscille comme pendule)</li>
                        <li><strong>Rendement</strong> : r√©cup√©ration √©lastique d'√©nergie lors de la locomotion</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- FLUIDES -->
        <div id="fluides" class="section">
            <div class="animation-block">
                <h2 class="block-title">üíß Loi de Poiseuille & √âcoulement Sanguin</h2>
                <canvas id="fluidesCanvas" width="1400" height="700"></canvas>
                
                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">
                            Rayon (r)
                            <span class="control-value" id="radiusVal">5.0</span> mm
                        </label>
                        <input type="range" id="radiusSlider" min="1" max="10" step="0.5" value="5">
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">
                            ŒîPression (ŒîP)
                            <span class="control-value" id="pressureVal">100</span> Pa
                        </label>
                        <input type="range" id="pressureSlider" min="10" max="300" step="10" value="100">
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">
                            Viscosit√© (Œ∑)
                            <span class="control-value" id="viscVal">4.0</span> mPa¬∑s
                        </label>
                        <input type="range" id="viscSlider" min="1" max="10" step="0.5" value="4">
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn" id="btnStartFlow">‚ñ∂Ô∏è √âCOULEMENT</button>
                    <button class="btn btn-secondary" id="btnStopFlow">‚è∏ PAUSE</button>
                </div>

                <div class="data-grid">
                    <div class="data-card"><div class="data-label">D√©bit (Q)</div><div class="data-value" id="flowVal">0.0 mL/s</div></div>
                    <div class="data-card"><div class="data-label">Vitesse moy</div><div class="data-value" id="avgVelVal">0.0 cm/s</div></div>
                    <div class="data-card"><div class="data-label">R√©sistance</div><div class="data-value" id="resistVal">0.0 Pa¬∑s/mL</div></div>
                    <div class="data-card"><div class="data-label">Reynolds</div><div class="data-value" id="reynoldsVal">0</div></div>
                </div>

                <div class="legend">
                    <div class="legend-item"><div class="legend-color" style="background: #ff6b6b;"></div><span>Particules de sang</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #ffe66d;"></div><span>Centre (v_max)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #4ecdc4;"></div><span>Lignes de courant</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #4facfe;"></div><span>Profil parabolique</span></div>
                </div>

                <div class="info-panel">
                    <h3>üìö Loi de Poiseuille (√©coulement laminaire)</h3>
                    <div class="equation">Q = (œÄŒîPr‚Å¥)/(8Œ∑L)</div>
                    <div class="equation">R = 8Œ∑L/(œÄr‚Å¥) (R√©sistance hydraulique)</div>
                    <div class="equation">Re = œÅvD/Œ∑ (Nombre de Reynolds)</div>
                    <ul>
                        <li><strong>CRITIQUE</strong> : D√©pendance en r‚Å¥ ! Diviser r par 2 ‚Üí Q divis√© par 16</li>
                        <li><strong>Application kin√©</strong> : compression vasculaire, drainage lymphatique</li>
                        <li><strong>Laminaire si Re < 2000</strong> : lignes de courant parall√®les, r√©sistance minimale</li>
                        <li><strong>Pathologie</strong> : ath√©roscl√©rose (‚Üìr) ‚Üí ‚Üë‚Üër√©sistance ‚Üí ‚Üì‚Üìd√©bit</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== GESTION NAVIGATION =====
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const sectionId = this.getAttribute('data-section');
                
                document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                
                document.getElementById(sectionId).classList.add('active');
                this.classList.add('active');
            });
        });

        // ===== CIN√âMATIQUE (MRUA) =====
        let mruaActive = false;
        let mruaTime = 0;
        let mruaTrajectory = [];
        let showVecs = true;

        const v0Slider = document.getElementById('v0Slider');
        const angleSlider = document.getElementById('angleSlider');
        const gSlider = document.getElementById('gSlider');

        v0Slider.oninput = () => document.getElementById('v0Val').textContent = v0Slider.value + '.0';
        angleSlider.oninput = () => document.getElementById('angleVal').textContent = angleSlider.value;
        gSlider.oninput = () => document.getElementById('gVal').textContent = gSlider.value;

        document.getElementById('btnLaunchMRUA').addEventListener('click', () => {
            mruaActive = true;
            mruaTime = 0;
            mruaTrajectory = [];
        });

        document.getElementById('btnResetMRUA').addEventListener('click', () => {
            mruaActive = false;
            mruaTime = 0;
            mruaTrajectory = [];
        });

        document.getElementById('btnToggleVectors').addEventListener('click', () => {
            showVecs = !showVecs;
        });

        function animateMRUA() {
            const canvas = document.getElementById('mruaCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, hCanvas = canvas.height;

            // Fond + grille
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, w, hCanvas);
            
            ctx.strokeStyle = 'rgba(102,126,234,0.15)';
            ctx.lineWidth = 1;
            for (let x = 0; x < w; x += 70) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, hCanvas); ctx.stroke();
            }
            for (let y = 0; y < hCanvas; y += 70) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
            }

            // Axes
            ctx.strokeStyle = 'rgba(255,255,255,0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(100, hCanvas - 80); ctx.lineTo(w - 100, hCanvas - 80); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(100, hCanvas - 80); ctx.lineTo(100, 80); ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = '18px monospace';
            ctx.fillText('x (m)', w - 150, hCanvas - 50);
            ctx.fillText('y (m)', 120, 100);

            if (mruaActive) {
                mruaTime += 0.03;
            }

            const v0 = parseFloat(v0Slider.value);
            const angle = parseFloat(angleSlider.value) * Math.PI / 180;
            const g = parseFloat(gSlider.value);

            const x = v0 * Math.cos(angle) * mruaTime;
            const y = v0 * Math.sin(angle) * mruaTime - 0.5 * g * mruaTime * mruaTime;

            const vx = v0 * Math.cos(angle);
            const vy = v0 * Math.sin(angle) - g * mruaTime;
            const v = Math.sqrt(vx*vx + vy*vy);

            const scale = 15;
            const px = 100 + x * scale;
            const py = hCanvas - 80 - y * scale;

            if (y >= 0 && mruaActive) {
                mruaTrajectory.push({x: px, y: py});
                if (mruaTrajectory.length > 600) mruaTrajectory.shift();
            }

            // Trajectoire
            if (mruaTrajectory.length > 1) {
                ctx.strokeStyle = '#ffe66d';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffe66d';
                ctx.beginPath();
                ctx.moveTo(mruaTrajectory[0].x, mruaTrajectory[0].y);
                mruaTrajectory.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Projectile
            if (y >= 0) {
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#667eea';
                ctx.beginPath();
                ctx.arc(px, py, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Vecteurs
                if (showVecs) {
                    const vs = 8;
                    // Vitesse
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px + vx*vs, py - vy*vs);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = 'bold 16px monospace';
                    ctx.fillText('v', px + vx*vs + 15, py - vy*vs);

                    // Acc√©l√©ration
                    ctx.strokeStyle = '#4ecdc4';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px, py + g*5);
                    ctx.stroke();
                    
                    ctx.fillStyle = '#4ecdc4';
                    ctx.fillText('g', px + 15, py + g*5);
                }
            } else {
                mruaActive = false;
            }

            // Donn√©es
            const tFlight = 2 * v0 * Math.sin(angle) / g;
            const hMax = (v0*v0 * Math.sin(angle)*Math.sin(angle)) / (2*g);
            const range = (v0*v0 * Math.sin(2*angle)) / g;

            document.getElementById('timeVal').textContent = mruaTime.toFixed(2) + ' s';
            document.getElementById('maxHeightVal').textContent = hMax.toFixed(1) + ' m';
            document.getElementById('rangeVal').textContent = range.toFixed(1) + ' m';
            document.getElementById('velVal').textContent = v.toFixed(1) + ' m/s';

            requestAnimationFrame(animateMRUA);
        }

        // ===== FORCES (Plan inclin√©) =====
        let planeActive = false;
        let planePos = 0;
        let planeVel = 0;

        const planeAngleSlider = document.getElementById('planeAngleSlider');
        const massSlider = document.getElementById('massSlider');
        const muSlider = document.getElementById('muSlider');

        planeAngleSlider.oninput = () => document.getElementById('planeAngleVal').textContent = planeAngleSlider.value;
        massSlider.oninput = () => document.getElementById('massVal').textContent = massSlider.value + '.0';
        muSlider.oninput = () => document.getElementById('muVal').textContent = muSlider.value;

        document.getElementById('btnSimulatePlane').addEventListener('click', () => {
            planeActive = true;
            planePos = 0;
            planeVel = 0;
        });

        document.getElementById('btnResetPlane').addEventListener('click', () => {
            planeActive = false;
            planePos = 0;
            planeVel = 0;
        });

        function animateForces() {
            const canvas = document.getElementById('forcesCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, hCanvas = canvas.height;

            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, w, hCanvas);

            const angle = parseFloat(planeAngleSlider.value) * Math.PI / 180;
            const mass = parseFloat(massSlider.value);
            const mu = parseFloat(muSlider.value);
            const g = 9.81;

            const weight = mass * g;
            const normal = weight * Math.cos(angle);
            const parallel = weight * Math.sin(angle);
            const friction = mu * normal;
            const netForce = parallel - friction;
            const accel = netForce / mass;

            if (planeActive) {
                planeVel += accel * 0.02;
                planePos += planeVel * 0.02;
                if (planePos < 0) {
                    planePos = 0;
                    planeVel = 0;
                }
            }

            // Plan
            ctx.save();
            ctx.translate(200, hCanvas - 150);

            ctx.strokeStyle = 'rgba(102,126,234,0.5)';
            ctx.fillStyle = 'rgba(102,126,234,0.15)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(1000, 0);
            ctx.lineTo(1000, -1000 * Math.tan(angle));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Objet
            const ox = 150 + planePos * 80;
            const oy = -ox * Math.tan(angle);

            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#667eea';
            ctx.fillRect(ox - 35, oy - 35, 70, 70);
            ctx.shadowBlur = 0;

            // Vecteurs forces
            const fs = 2.5;

            // Poids
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(ox, oy + weight*fs);
            ctx.stroke();
            ctx.fillStyle = '#ff6b6b';
            ctx.font = 'bold 18px monospace';
            ctx.fillText('W', ox + 15, oy + weight*fs/2);

            // Normale
            ctx.strokeStyle = '#4ecdc4';
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(ox - normal*fs*Math.sin(angle), oy - normal*fs*Math.cos(angle));
            ctx.stroke();
            ctx.fillStyle = '#4ecdc4';
            ctx.fillText('N', ox - 40, oy - 40);

            // Friction
            ctx.strokeStyle = '#ffe66d';
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(ox - friction*fs*Math.cos(angle), oy + friction*fs*Math.sin(angle));
            ctx.stroke();
            ctx.fillStyle = '#ffe66d';
            ctx.fillText('f', ox - 70, oy + 15);

            ctx.restore();

            // Donn√©es
            document.getElementById('weightVal').textContent = weight.toFixed(1) + ' N';
            document.getElementById('normalVal').textContent = normal.toFixed(1) + ' N';
            document.getElementById('parVal').textContent = parallel.toFixed(1) + ' N';
            document.getElementById('fricVal').textContent = friction.toFixed(1) + ' N';
            document.getElementById('netVal').textContent = netForce.toFixed(1) + ' N';
            document.getElementById('accelVal').textContent = accel.toFixed(2) + ' m/s¬≤';

            requestAnimationFrame(animateForces);
        }

        // ===== √âNERGIE (Pendule) =====
        let pendActive = false;
        let pendTheta = 0;
        let pendOmega = 0;

        const lengthSlider = document.getElementById('lengthSlider');
        const theta0Slider = document.getElementById('theta0Slider');

        lengthSlider.oninput = () => document.getElementById('lengthVal').textContent = lengthSlider.value;
        theta0Slider.oninput = () => document.getElementById('theta0Val').textContent = theta0Slider.value;

        document.getElementById('btnLaunchPendulum').addEventListener('click', () => {
            pendActive = true;
            pendTheta = parseFloat(theta0Slider.value) * Math.PI / 180;
            pendOmega = 0;
        });

        document.getElementById('btnResetPendulum').addEventListener('click', () => {
            pendActive = false;
            pendTheta = 0;
            pendOmega = 0;
        });

        function animateEnergie() {
            const canvas = document.getElementById('energieCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, hCanvas = canvas.height;

            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, w, hCanvas);

            const L = parseFloat(lengthSlider.value) * 80;
            const mass = 2;
            const g = 9.81;

            const cx = w / 2;
            const cy = 150;

            if (pendActive) {
                const alpha = -(g / (L/80)) * Math.sin(pendTheta);
                pendOmega += alpha * 0.02;
                pendTheta += pendOmega * 0.02;
            }

            const px = cx + L * Math.sin(pendTheta);
            const py = cy + L * Math.cos(pendTheta);

            // Fil
            ctx.strokeStyle = 'rgba(102,126,234,0.6)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(px, py);
            ctx.stroke();

            // Support
            ctx.fillStyle = '#888';
            ctx.fillRect(cx - 50, cy - 20, 100, 20);

            // Masse
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#667eea';
            ctx.beginPath();
            ctx.arc(px, py, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // √ânergies
            const heightPend = L/80 * (1 - Math.cos(pendTheta));
            const v = pendOmega * L/80;
            const ke = 0.5 * mass * v * v;
            const pe = mass * g * heightPend;
            const te = ke + pe;

            // Barres √©nergie
            const barX = 100;
            const barY = hCanvas - 200;
            const barW = 60;

            ctx.fillStyle = 'rgba(255,107,107,0.3)';
            ctx.fillRect(barX, barY - ke*5, barW, ke*5);
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(barX, barY - ke*5, barW, 3);
            ctx.font = 'bold 14px monospace';
            ctx.fillText('E_cin', barX, barY + 30);

            ctx.fillStyle = 'rgba(78,205,196,0.3)';
            ctx.fillRect(barX + 100, barY - pe*5, barW, pe*5);
            ctx.fillStyle = '#4ecdc4';
            ctx.fillRect(barX + 100, barY - pe*5, barW, 3);
            ctx.fillText('E_pot', barX + 100, barY + 30);

            ctx.fillStyle = 'rgba(255,230,109,0.3)';
            ctx.fillRect(barX + 200, barY - te*5, barW, te*5);
            ctx.fillStyle = '#ffe66d';
            ctx.fillRect(barX + 200, barY - te*5, barW, 3);
            ctx.fillText('E_tot', barX + 200, barY + 30);

            // Donn√©es
            document.getElementById('thetaPVal').textContent = (pendTheta * 180/Math.PI).toFixed(0) + '¬∞';
            document.getElementById('velPVal').textContent = v.toFixed(2) + ' m/s';
            document.getElementById('kePVal').textContent = ke.toFixed(1) + ' J';
            document.getElementById('pePVal').textContent = pe.toFixed(1) + ' J';
            document.getElementById('tePVal').textContent = te.toFixed(1) + ' J';

            requestAnimationFrame(animateEnergie);
        }

        // ===== FLUIDES (Poiseuille) =====
        let flowActive = false;
        let particles = [];

        const radiusSlider = document.getElementById('radiusSlider');
        const pressureSlider = document.getElementById('pressureSlider');
        const viscSlider = document.getElementById('viscSlider');

        // Mise √† jour des valeurs affich√©es
        radiusSlider.oninput = () => {
            document.getElementById('radiusVal').textContent = radiusSlider.value;
            // R√©initialiser les particules quand le rayon change
            if (flowActive) {
                initFluidParticles();
            }
        };
        pressureSlider.oninput = () => {
            document.getElementById('pressureVal').textContent = pressureSlider.value;
        };
        viscSlider.oninput = () => {
            document.getElementById('viscVal').textContent = viscSlider.value;
        };

        // Fonction d'initialisation des particules
        function initFluidParticles() {
            particles = [];
            const r = parseFloat(radiusSlider.value) * 10;
            for (let i = 0; i < 120; i++) {
                particles.push({
                    x: Math.random() * 1000 + 150,
                    y: (Math.random() * 2 - 1) * r * 0.95,
                    r: Math.random() * 2 + 2,
                    trail: []
                });
            }
        }

        document.getElementById('btnStartFlow').addEventListener('click', () => {
            flowActive = true;
            if (particles.length === 0) {
                initFluidParticles();
            }
        });

        document.getElementById('btnStopFlow').addEventListener('click', () => {
            flowActive = false;
        });


        function animateFluides() {
            const canvas = document.getElementById('fluidesCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, hCanvas = canvas.height;

            // Fond sombre avec l√©g√®re transparence
            ctx.fillStyle = 'rgba(10, 15, 30, 0.95)';
            ctx.fillRect(0, 0, w, hCanvas);

            // R√©cup√©ration des param√®tres depuis les sliders
            const r = parseFloat(radiusSlider.value) * 10;
            const dP = parseFloat(pressureSlider.value);
            const visc = parseFloat(viscSlider.value);
            const L = 1000; // Longueur du vaisseau en pixels

            // === CALCULS PHYSIOLOGIQUES (Loi de Poiseuille) ===
            const Q = (Math.PI * dP * Math.pow(r/10, 4)) / (8 * visc/1000 * L/1000);
            const avgVel = Q / (Math.PI * Math.pow(r/10, 2)) * 100;
            const R = (8 * visc/1000 * L/1000) / (Math.PI * Math.pow(r/10, 4));
            const rho = 1050; // Densit√© du sang kg/m¬≥
            const D = 2 * r/10 / 100; // Diam√®tre en m
            const Re = rho * avgVel/100 * D / (visc/1000); // Nombre de Reynolds

            const vesselStart = 150;
            const vesselEnd = w - 250;
            const centerY = hCanvas / 2;

            // === TITRE PRINCIPAL ===
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('LOI DE POISEUILLE - √âCOULEMENT SANGUIN', w/2, 40);
            ctx.textAlign = 'left';
            
            // === INDICATEUR DE VISCOSIT√â ===
            ctx.font = 'bold 22px monospace';
            ctx.fillText(`VISCOSIT√â: ${visc.toFixed(1)} mPa¬∑s`, 50, 90);
            
            const viscMax = 10;
            const viscBarWidth = 300;
            const viscRatio = visc / viscMax;
            
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.fillRect(50, 110, viscBarWidth, 25);
            
            const viscGrad = ctx.createLinearGradient(50, 110, 50 + viscBarWidth, 110);
            viscGrad.addColorStop(0, '#4facfe');     // Faible = Bleu (rapide)
            viscGrad.addColorStop(0.5, '#ffe66d');   // Moyenne = Jaune
            viscGrad.addColorStop(1, '#ff6b6b');     // Haute = Rouge (lent)
            
            ctx.fillStyle = viscGrad;
            ctx.fillRect(50, 110, viscBarWidth * viscRatio, 25);
            
            ctx.strokeStyle = 'rgba(102,126,234,0.6)';
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 110, viscBarWidth, 25);
            
            ctx.fillStyle = viscRatio < 0.3 ? '#4facfe' : (viscRatio < 0.7 ? '#ffe66d' : '#ff6b6b');
            ctx.font = 'bold 16px monospace';
            const viscLabel = viscRatio < 0.3 ? 'üíß FLUIDE (√©coulement rapide)' : 
                             (viscRatio < 0.7 ? 'üåä MOYEN (sang normal)' : 'üçØ VISQUEUX (√©coulement lent)');
            ctx.fillText(viscLabel, 370, 128);

            // === INDICATEUR DE VITESSE (SPEEDOMETER) ===
            const speedoX = w - 180;
            const speedoY = 150;
            const speedoR = 70;
            
            // Arc de fond
            ctx.strokeStyle = 'rgba(102,126,234,0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(speedoX, speedoY, speedoR, 0.75 * Math.PI, 2.25 * Math.PI);
            ctx.stroke();
            
            // Graduations color√©es
            for (let i = 0; i <= 10; i++) {
                const angle = 0.75 * Math.PI + (i / 10) * 1.5 * Math.PI;
                const x1 = speedoX + Math.cos(angle) * (speedoR - 10);
                const y1 = speedoY + Math.sin(angle) * (speedoR - 10);
                const x2 = speedoX + Math.cos(angle) * speedoR;
                const y2 = speedoY + Math.sin(angle) * speedoR;
                
                ctx.strokeStyle = i <= 3 ? '#4facfe' : (i <= 7 ? '#ffe66d' : '#ff6b6b');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Aiguille
            const maxVelDisplay = 50; // cm/s max
            const needleAngle = 0.75 * Math.PI + (Math.min(avgVel, maxVelDisplay) / maxVelDisplay) * 1.5 * Math.PI;
            const needleLength = speedoR - 15;
            
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#667eea';
            ctx.beginPath();
            ctx.moveTo(speedoX, speedoY);
            ctx.lineTo(speedoX + Math.cos(needleAngle) * needleLength, 
                       speedoY + Math.sin(needleAngle) * needleLength);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Point central
            ctx.fillStyle = '#667eea';
            ctx.beginPath();
            ctx.arc(speedoX, speedoY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Valeur de vitesse
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`${avgVel.toFixed(1)}`, speedoX, speedoY + 50);
            ctx.font = '12px monospace';
            ctx.fillText('cm/s', speedoX, speedoY + 65);
            ctx.textAlign = 'left';

            // === GRADIENT DE VITESSE (carte de chaleur dans le vaisseau) ===
            if (flowActive) {
                const gradient = ctx.createRadialGradient(
                    vesselStart + L/2, centerY, 0, 
                    vesselStart + L/2, centerY, r
                );
                gradient.addColorStop(0, 'rgba(255, 255, 50, 0.4)');  // Jaune au centre (rapide)
                gradient.addColorStop(0.5, 'rgba(255, 150, 50, 0.25)'); // Orange
                gradient.addColorStop(1, 'rgba(255, 50, 50, 0.15)');  // Rouge aux bords (lent)
                
                ctx.fillStyle = gradient;
                ctx.fillRect(vesselStart, centerY - r, vesselEnd - vesselStart, 2*r);
            }

            // === PAROIS DU VAISSEAU ===
            ctx.strokeStyle = 'rgba(102,126,234,0.8)';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(vesselStart, centerY - r);
            ctx.lineTo(vesselEnd, centerY - r);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(vesselStart, centerY + r);
            ctx.lineTo(vesselEnd, centerY + r);
            ctx.stroke();

            // Zones d'entr√©e et sortie
            ctx.fillStyle = 'rgba(102,126,234,0.3)';
            ctx.fillRect(vesselStart - 20, centerY - r, 20, 2*r);
            ctx.fillRect(vesselEnd, centerY - r, 20, 2*r);

            // === LIGNES DE COURANT (Streamlines) ===
            if (flowActive) {
                ctx.strokeStyle = 'rgba(78,205,196,0.5)';
                ctx.lineWidth = 2;
                const numStreamlines = 9;
                
                for (let i = 0; i < numStreamlines; i++) {
                    const yPos = centerY + (i - (numStreamlines-1)/2) * (r * 1.8 / numStreamlines);
                    const distFromCenter = Math.abs(yPos - centerY);
                    const vRatio = Math.max(0, 1 - Math.pow(distFromCenter / r, 2));
                    
                    if (vRatio > 0) {
                        ctx.beginPath();
                        ctx.setLineDash([10 * vRatio + 5, 5]);
                        ctx.moveTo(vesselStart, yPos);
                        ctx.lineTo(vesselEnd, yPos);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }

            // === PARTICULES ANIM√âES (Globules rouges) ===
            if (flowActive && particles.length > 0) {
                // Facteur de vitesse : plus la viscosit√© est √©lev√©e, plus c'est lent
                const speedFactor = 0.6 * (5 / visc);
                
                particles.forEach((p) => {
                    const distFromCenter = Math.abs(p.y);
                    const normalizedDist = distFromCenter / r;
                    
                    if (normalizedDist <= 1) {
                        // Profil parabolique : v(r) = v_max(1 - (r/R)¬≤)
                        const vMax = 2 * avgVel;
                        const v = vMax * (1 - normalizedDist * normalizedDist);
                        
                        // Gestion de la tra√Æn√©e
                        if (!p.trail) p.trail = [];
                        p.trail.push({x: p.x, y: p.y});
                        if (p.trail.length > 18) p.trail.shift();
                        
                        // D√©placement
                        p.x += v * speedFactor * 0.35;
                        
                        // R√©initialisation si sortie
                        if (p.x > vesselEnd) {
                            p.x = vesselStart + 10;
                            p.y = (Math.random() * 2 - 1) * r * 0.95;
                            p.trail = [];
                        }

                        // Dessin de la tra√Æn√©e
                        if (p.trail.length > 1) {
                            const speedRatio = v / vMax;
                            ctx.strokeStyle = `rgba(255, 107, 107, ${0.5 * speedRatio})`;
                            ctx.lineWidth = 2.5;
                            ctx.beginPath();
                            ctx.moveTo(p.trail[0].x, centerY + p.trail[0].y);
                            for (let i = 1; i < p.trail.length; i++) {
                                ctx.lineTo(p.trail[i].x, centerY + p.trail[i].y);
                            }
                            ctx.stroke();
                        }

                        // Dessin de la particule (couleur bas√©e sur vitesse)
                        const speedRatio = v / vMax;
                        const hue = 0 + speedRatio * 25;  // Rouge -> Orange
                        const lightness = 50 + speedRatio * 30;
                        
                        ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                        ctx.shadowBlur = 14 + speedRatio * 10;
                        ctx.shadowColor = `hsl(${hue}, 100%, ${lightness}%)`;
                        ctx.beginPath();
                        ctx.arc(p.x, centerY + p.y, p.r + speedRatio * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                });
            }

            // === PROFIL DE VITESSE (Graphique) ===
            const graphX = vesselEnd + 60;
            const graphW = 180;
            const graphH = 2*r + 40;
            
            // Cadre
            ctx.strokeStyle = 'rgba(102,126,234,0.6)';
            ctx.lineWidth = 2;
            ctx.strokeRect(graphX, centerY - r - 20, graphW, graphH);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px monospace';
            ctx.fillText('Profil vitesse', graphX + 10, centerY - r - 30);
            
            // Axe central
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(graphX + 10, centerY - r);
            ctx.lineTo(graphX + 10, centerY + r);
            ctx.stroke();
            
            // Ligne de sym√©trie
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'rgba(255,230,109,0.5)';
            ctx.beginPath();
            ctx.moveTo(graphX, centerY);
            ctx.lineTo(graphX + graphW - 10, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Courbe parabolique
            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#4facfe';
            ctx.beginPath();
            
            const numPoints = 60;
            for (let i = 0; i <= numPoints; i++) {
                const yOffset = (i / numPoints - 0.5) * 2 * r;
                const normalizedDist = Math.abs(yOffset) / r;
                const vRatio = Math.max(0, 1 - normalizedDist * normalizedDist);
                const xOffset = vRatio * (graphW - 30);
                
                if (i === 0) {
                    ctx.moveTo(graphX + 10, centerY + yOffset);
                } else {
                    ctx.lineTo(graphX + 15 + xOffset, centerY + yOffset);
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Labels
            ctx.fillStyle = '#4facfe';
            ctx.font = 'bold 14px monospace';
            ctx.fillText('v_max', graphX + graphW - 55, centerY - 5);
            ctx.fillText('0', graphX + 10, centerY + r + 18);
            ctx.fillText('r', graphX - 20, centerY - r);
            ctx.fillText('-r', graphX - 25, centerY + r + 5);

            // === ANNOTATIONS DE PRESSION ===
            // Fl√®che P‚ÇÅ
            ctx.strokeStyle = '#f093fb';
            ctx.fillStyle = '#f093fb';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(vesselStart - 50, centerY);
            ctx.lineTo(vesselStart - 10, centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(vesselStart - 10, centerY);
            ctx.lineTo(vesselStart - 20, centerY - 8);
            ctx.lineTo(vesselStart - 20, centerY + 8);
            ctx.closePath();
            ctx.fill();
            ctx.font = 'bold 18px monospace';
            ctx.fillText('P‚ÇÅ', vesselStart - 80, centerY + 5);
            
            // Fl√®che P‚ÇÇ
            ctx.strokeStyle = '#4facfe';
            ctx.fillStyle = '#4facfe';
            ctx.beginPath();
            ctx.moveTo(vesselEnd + 10, centerY);
            ctx.lineTo(vesselEnd + 40, centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(vesselEnd + 40, centerY);
            ctx.lineTo(vesselEnd + 30, centerY - 8);
            ctx.lineTo(vesselEnd + 30, centerY + 8);
            ctx.closePath();
            ctx.fill();
            ctx.fillText('P‚ÇÇ', vesselEnd + 45, centerY + 5);

            // Diff√©rence de pression
            ctx.fillStyle = '#ffe66d';
            ctx.font = 'bold 20px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`ŒîP = ${dP} Pa`, w/2, centerY - r - 40);
            ctx.textAlign = 'left';

            // === R√âGIME D'√âCOULEMENT ===
            ctx.fillStyle = Re < 2000 ? '#4ecdc4' : '#ff6b6b';
            ctx.font = 'bold 18px monospace';
            const regime = Re < 2000 ? 'üîµ LAMINAIRE' : 'üî¥ TURBULENT';
            ctx.textAlign = 'center';
            ctx.fillText(regime, w/2, 680);
            ctx.textAlign = 'left';

            // === MISE √Ä JOUR DES DONN√âES AFFICH√âES ===
            document.getElementById('flowVal').textContent = Q.toFixed(2) + ' mL/s';
            document.getElementById('avgVelVal').textContent = avgVel.toFixed(1) + ' cm/s';
            document.getElementById('resistVal').textContent = R.toFixed(3) + ' Pa¬∑s/mL';
            document.getElementById('reynoldsVal').textContent = Re.toFixed(0);

            requestAnimationFrame(animateFluides);
        }

        // Lancement animations
        animateMRUA();
        animateForces();
        animateEnergie();
        animateFluides();
    </script>
</body>
</html>
